#!/usr/bin/env tsx
/**
 * Plugin Documentation Generator
 *
 * Automatically generates comprehensive documentation from all plugin registries:
 * - NodeTypeRegistry ‚Üí Available Node Types
 * - NodeRendererRegistry ‚Üí Custom Renderers
 * - InteractionRegistry ‚Üí Interaction Plugins
 * - SessionHelperRegistry ‚Üí Helper Functions
 *
 * Usage: npm run generate-docs
 */

import * as fs from 'fs';
import * as path from 'path';

// Import registries using relative paths
import { nodeTypeRegistry, NodeTypeDefinition } from '../../../../shared/graph-core/src/nodeTypeRegistry.js';
import { registerBuiltinNodeTypes } from '../../../../shared/graph-core/src/builtinNodeTypes.js';

interface RegistrySection {
  title: string;
  description: string;
  items: any[];
}

/**
 * Generate markdown documentation for all plugin registries
 */
function generatePluginDocs(): string {
  const sections: string[] = [];

  // Header
  sections.push('# üîå Plugin Reference\n');
  sections.push('> Auto-generated documentation for all PixSim7 plugin systems\n');
  sections.push(`_Last updated: ${new Date().toISOString()}_\n`);
  sections.push('---\n');

  // Table of Contents
  sections.push('## üìë Table of Contents\n');
  sections.push('1. [Node Types](#-node-types) - Available scene node types');
  sections.push('2. [Node Renderers](#-node-renderers) - Custom visual renderers');
  sections.push('3. [Interaction Plugins](#-interaction-plugins) - NPC interaction systems');
  sections.push('4. [Session Helpers](#-session-helpers) - Game session manipulation API\n');
  sections.push('---\n');

  // 1. Node Types
  sections.push(generateNodeTypesSection());

  // 2. Node Renderers
  sections.push(generateNodeRenderersSection());

  // 3. Interaction Plugins
  sections.push(generateInteractionPluginsSection());

  // 4. Session Helpers
  sections.push(generateSessionHelpersSection());

  // Footer
  sections.push('---\n');
  sections.push('## üöÄ Adding Your Own Plugins\n');
  sections.push('### Creating a Custom Node Type\n');
  sections.push('```typescript');
  sections.push("import { nodeTypeRegistry } from '@pixsim7/shared.graph.core';");
  sections.push('');
  sections.push('nodeTypeRegistry.register({');
  sections.push("  id: 'my_custom_node',");
  sections.push("  name: 'My Custom Node',");
  sections.push("  description: 'Does something amazing',");
  sections.push("  icon: '‚ú®',");
  sections.push("  category: 'custom',");
  sections.push('  userCreatable: true,');
  sections.push('  defaultData: {');
  sections.push('    // Your default node data');
  sections.push('  },');
  sections.push("  editorComponent: 'MyCustomNodeEditor',");
  sections.push('});');
  sections.push('```\n');

  sections.push('### Creating an Interaction Plugin\n');
  sections.push('```typescript');
  sections.push("import { interactionRegistry, InteractionPlugin } from 'frontend/lib/game/interactions';");
  sections.push('');
  sections.push('const myPlugin: InteractionPlugin<MyConfig> = {');
  sections.push("  id: 'my_interaction',");
  sections.push("  name: 'My Interaction',");
  sections.push("  description: 'Custom interaction behavior',");
  sections.push("  icon: '‚ö°',");
  sections.push('  defaultConfig: { enabled: true },');
  sections.push('  configFields: [');
  sections.push('    { key: "param", label: "Parameter", type: "text" }');
  sections.push('  ],');
  sections.push('  async execute(config, context) {');
  sections.push('    // Your interaction logic');
  sections.push('    return { success: true, message: "Done!" };');
  sections.push('  }');
  sections.push('};');
  sections.push('');
  sections.push('interactionRegistry.register(myPlugin);');
  sections.push('```\n');

  sections.push('### Creating a Custom Renderer\n');
  sections.push('```typescript');
  sections.push("import { nodeRendererRegistry } from 'frontend/lib/graph/nodeRendererRegistry';");
  sections.push("import MyRenderer from './MyRenderer.svelte';");
  sections.push('');
  sections.push('nodeRendererRegistry.register({');
  sections.push("  nodeType: 'my_custom_node',");
  sections.push('  component: MyRenderer,');
  sections.push('  defaultSize: { width: 200, height: 150 }');
  sections.push('});');
  sections.push('```\n');

  sections.push('---\n');
  sections.push('_Generated by `packages/game-core/src/utils/generatePluginDocs.ts`_\n');

  return sections.join('\n');
}

/**
 * Generate Node Types documentation section
 */
function generateNodeTypesSection(): string {
  const lines: string[] = [];

  lines.push('## üéØ Node Types\n');
  lines.push('Node types define the building blocks of scenes in PixSim7. Each node represents a discrete unit of gameplay logic.\n');

  const allTypes = nodeTypeRegistry.getAll();
  const categories = new Map<string, NodeTypeDefinition[]>();

  // Group by category
  allTypes.forEach(type => {
    const cat = type.category || 'custom';
    if (!categories.has(cat)) {
      categories.set(cat, []);
    }
    categories.get(cat)!.push(type);
  });

  lines.push(`**Total Registered:** ${allTypes.length} node types\n`);

  // Generate table of all nodes
  lines.push('### Quick Reference\n');
  lines.push('| Icon | Name | ID | Category | User Creatable |');
  lines.push('|------|------|----|----------|----------------|');

  allTypes.forEach(type => {
    const icon = type.icon || 'üì¶';
    const creatable = type.userCreatable ? '‚úÖ' : '‚ùå';
    const category = type.category || 'custom';
    lines.push(`| ${icon} | **${type.name}** | \`${type.id}\` | ${category} | ${creatable} |`);
  });
  lines.push('');

  // Detailed sections by category
  lines.push('### By Category\n');

  const categoryOrder = ['media', 'flow', 'logic', 'action', 'custom'];
  const categoryEmojis: Record<string, string> = {
    media: 'üé¨',
    flow: 'üîÄ',
    logic: 'üß†',
    action: '‚ö°',
    custom: 'üîß'
  };

  categoryOrder.forEach(catName => {
    const types = categories.get(catName);
    if (!types || types.length === 0) return;

    const emoji = categoryEmojis[catName] || 'üì¶';
    lines.push(`#### ${emoji} ${catName.toUpperCase()}\n`);

    types.forEach(type => {
      lines.push(`##### ${type.icon || 'üì¶'} ${type.name} (\`${type.id}\`)\n`);

      if (type.description) {
        lines.push(`${type.description}\n`);
      }

      lines.push('**Properties:**');
      lines.push('```typescript');
      lines.push(`id: "${type.id}"`);
      lines.push(`category: "${type.category || 'custom'}"`);
      lines.push(`userCreatable: ${type.userCreatable || false}`);

      if (type.editorComponent) {
        lines.push(`editorComponent: "${type.editorComponent}"`);
      }
      if (type.rendererComponent) {
        lines.push(`rendererComponent: "${type.rendererComponent}"`);
      }
      if (type.color) {
        lines.push(`color: "${type.color}"`);
      }
      if (type.bgColor) {
        lines.push(`bgColor: "${type.bgColor}"`);
      }
      lines.push('```\n');

      // Default data
      if (type.defaultData && Object.keys(type.defaultData).length > 0) {
        lines.push('**Default Data:**');
        lines.push('```json');
        lines.push(JSON.stringify(type.defaultData, null, 2));
        lines.push('```\n');
      }

      // Usage example
      lines.push('**Usage Example:**');
      lines.push('```typescript');
      lines.push(`const ${type.id}Node: SceneNode = {`);
      lines.push('  id: "node_1",');
      lines.push(`  type: "${type.id}",`);
      lines.push('  data: {');
      lines.push('    ...nodeTypeRegistry.get("' + type.id + '").defaultData,');
      lines.push('    // Override properties as needed');
      lines.push('  },');
      lines.push('  transitions: []');
      lines.push('};');
      lines.push('```\n');

      lines.push('---\n');
    });
  });

  return lines.join('\n');
}

/**
 * Generate Node Renderers documentation section
 */
function generateNodeRenderersSection(): string {
  const lines: string[] = [];

  lines.push('## üé® Node Renderers\n');
  lines.push('Node renderers define how nodes are visually displayed in the graph editor. Each renderer is a Svelte component.\n');

  lines.push('**Location:** `frontend/src/lib/graph/`\n');
  lines.push('**Registry:** `nodeRendererRegistry`\n');

  lines.push('### Available Renderers\n');

  // Since we can't import frontend code, document the structure
  const knownRenderers = [
    {
      nodeType: 'default',
      component: 'DefaultNodeRenderer',
      description: 'Fallback renderer for all node types',
      defaultSize: { width: 200, height: 120 },
      features: ['Node icon and name', 'Basic info display', 'Standard header']
    },
    {
      nodeType: 'video',
      component: 'VideoNodeRenderer',
      description: 'Displays media nodes with thumbnail and playback info',
      defaultSize: { width: 220, height: 180 },
      features: ['Media thumbnail preview', 'Playback mode indicator', 'Media selection display']
    },
    {
      nodeType: 'choice',
      component: 'ChoiceNodeRenderer',
      description: 'Shows available player choices',
      defaultSize: { width: 200, height: 150 },
      features: ['Choice list display', 'Choice text preview', 'Branch indicators']
    },
    {
      nodeType: 'miniGame',
      component: 'VideoNodeRenderer',
      description: 'Reuses video renderer for mini-game nodes',
      defaultSize: { width: 220, height: 180 },
      features: ['Game thumbnail', 'Configuration preview']
    }
  ];

  knownRenderers.forEach(renderer => {
    lines.push(`#### \`${renderer.nodeType}\` ‚Üí ${renderer.component}\n`);
    lines.push(`${renderer.description}\n`);

    lines.push('**Default Size:**');
    lines.push('```typescript');
    lines.push(JSON.stringify(renderer.defaultSize, null, 2));
    lines.push('```\n');

    lines.push('**Features:**');
    renderer.features.forEach(feature => {
      lines.push(`- ${feature}`);
    });
    lines.push('');

    lines.push('**Registration:**');
    lines.push('```typescript');
    lines.push('nodeRendererRegistry.register({');
    lines.push(`  nodeType: '${renderer.nodeType}',`);
    lines.push(`  component: ${renderer.component},`);
    lines.push(`  defaultSize: ${JSON.stringify(renderer.defaultSize)}`);
    lines.push('});');
    lines.push('```\n');

    lines.push('---\n');
  });

  lines.push('### Renderer Interface\n');
  lines.push('```typescript');
  lines.push('interface NodeRendererProps {');
  lines.push('  node: DraftSceneNode;      // The node being rendered');
  lines.push('  isSelected: boolean;       // Whether node is selected');
  lines.push('  isStart: boolean;          // Whether this is the start node');
  lines.push('  hasErrors: boolean;        // Whether node has validation errors');
  lines.push('}');
  lines.push('');
  lines.push('interface NodeRenderer {');
  lines.push('  nodeType: string;');
  lines.push('  component: ComponentType<NodeRendererProps>;');
  lines.push('  defaultSize?: { width: number; height: number };');
  lines.push('  customHeader?: boolean;    // Use custom header (default: false)');
  lines.push('}');
  lines.push('```\n');

  return lines.join('\n');
}

/**
 * Generate Interaction Plugins documentation section
 */
function generateInteractionPluginsSection(): string {
  const lines: string[] = [];

  lines.push('## ü§ù Interaction Plugins\n');
  lines.push('Interaction plugins define actions players can take when interacting with NPCs in the game world.\n');

  lines.push('**Location:** `frontend/src/lib/game/interactions/`\n');
  lines.push('**Registry:** `interactionRegistry`\n');

  lines.push('### Built-in Interactions\n');

  const interactions = [
    {
      id: 'talk',
      name: 'Talk',
      icon: 'üí¨',
      description: 'Start a conversation with the NPC',
      configFields: [
        { key: 'npcId', label: 'NPC ID Override', type: 'number', description: 'Optional: Override which NPC to talk to' },
        { key: 'preferredSceneId', label: 'Preferred Scene ID', type: 'number', description: 'The scene to play when talking to this NPC' }
      ],
      example: {
        enabled: true,
        npcId: null,
        preferredSceneId: 42
      }
    },
    {
      id: 'pickpocket',
      name: 'Pickpocket',
      icon: 'ü§è',
      description: 'Attempt to steal from the NPC',
      configFields: [
        { key: 'baseSuccessChance', label: 'Success Chance (0-1)', type: 'number', min: 0, max: 1, step: 0.1, description: 'Base probability of successful pickpocket' },
        { key: 'detectionChance', label: 'Detection Chance (0-1)', type: 'number', min: 0, max: 1, step: 0.1, description: 'Probability of being caught' },
        { key: 'onSuccessFlags', label: 'Success Flags', type: 'tags', description: 'Flags to set when pickpocket succeeds' },
        { key: 'onFailFlags', label: 'Fail Flags', type: 'tags', description: 'Flags to set when pickpocket fails' }
      ],
      example: {
        enabled: true,
        baseSuccessChance: 0.4,
        detectionChance: 0.3,
        onSuccessFlags: ['stealth:stole_from_npc'],
        onFailFlags: ['stealth:caught_by_npc']
      }
    },
    {
      id: 'give_item',
      name: 'Give Item',
      icon: 'üéÅ',
      description: 'Offer an item to the NPC',
      configFields: [
        { key: 'itemId', label: 'Item ID', type: 'text', placeholder: 'e.g., flower, gift, letter' },
        { key: 'requiredRelationship', label: 'Required Relationship Level', type: 'number', min: 0, max: 100 },
        { key: 'rewardSceneId', label: 'Reward Scene (if accepted)', type: 'number', placeholder: 'Scene ID' },
        { key: 'rejectSceneId', label: 'Reject Scene (if declined)', type: 'number', placeholder: 'Scene ID' }
      ],
      example: {
        enabled: true,
        itemId: 'flower',
        requiredRelationship: 20,
        rewardSceneId: 100,
        rejectSceneId: 101
      }
    }
  ];

  interactions.forEach(plugin => {
    lines.push(`### ${plugin.icon} ${plugin.name} (\`${plugin.id}\`)\n`);
    lines.push(`${plugin.description}\n`);

    lines.push('**Configuration Fields:**\n');
    lines.push('| Field | Type | Description |');
    lines.push('|-------|------|-------------|');
    plugin.configFields.forEach(field => {
      const typeInfo = field.type + (field.min !== undefined ? ` (${field.min}-${field.max})` : '');
      lines.push(`| \`${field.key}\` | ${typeInfo} | ${field.description || field.label} |`);
    });
    lines.push('');

    lines.push('**Default Configuration:**');
    lines.push('```json');
    lines.push(JSON.stringify(plugin.example, null, 2));
    lines.push('```\n');

    lines.push('**Usage Example:**');
    lines.push('```typescript');
    lines.push("import { interactionRegistry } from 'frontend/lib/game/interactions';");
    lines.push('');
    lines.push(`const result = await executeInteraction('${plugin.id}', {`);
    Object.entries(plugin.example).forEach(([key, value]) => {
      const valueStr = typeof value === 'string' ? `'${value}'` : JSON.stringify(value);
      lines.push(`  ${key}: ${valueStr},`);
    });
    lines.push('}, context);');
    lines.push('');
    lines.push('if (result.success) {');
    lines.push('  console.log("Interaction succeeded:", result.message);');
    lines.push('} else {');
    lines.push('  console.error("Interaction failed:", result.message);');
    lines.push('}');
    lines.push('```\n');

    lines.push('---\n');
  });

  lines.push('### Plugin Interface\n');
  lines.push('```typescript');
  lines.push('interface InteractionPlugin<TConfig extends BaseInteractionConfig> {');
  lines.push('  id: string;                           // Unique plugin ID');
  lines.push('  name: string;                         // Display name');
  lines.push('  description: string;                  // Short description');
  lines.push('  icon?: string;                        // Emoji or icon');
  lines.push('  defaultConfig: TConfig;               // Default configuration');
  lines.push('  configFields: FormField[];            // Auto-generates UI forms');
  lines.push('  execute: (config: TConfig, context: InteractionContext) => Promise<InteractionResult>;');
  lines.push('  validate?: (config: TConfig) => string | null;');
  lines.push('  isAvailable?: (context: InteractionContext) => boolean;');
  lines.push('}');
  lines.push('```\n');

  return lines.join('\n');
}

/**
 * Generate Session Helpers documentation section
 */
function generateSessionHelpersSection(): string {
  const lines: string[] = [];

  lines.push('## üéÆ Session Helpers\n');
  lines.push('Session helpers provide a clean API for manipulating game session state with optimistic updates and conflict resolution.\n');

  lines.push('**Location:** `frontend/src/lib/game/interactions/sessionAdapter.ts`\n');
  lines.push('**Pattern:** Factory Function (not a traditional registry)\n');

  lines.push('### Overview\n');
  lines.push('Session helpers are created via the `createSessionHelpers()` factory function, which provides:');
  lines.push('- **Optimistic updates** - Changes apply instantly to UI, then validate server-side');
  lines.push('- **Conflict resolution** - Automatic handling of version conflicts');
  lines.push('- **Rollback on error** - Failed updates restore previous state');
  lines.push('- **Type safety** - Full TypeScript support\n');

  lines.push('### Available Helper Functions\n');

  const helpers = [
    {
      name: 'getNpcRelationship',
      signature: '(npcId: number) => NpcRelationshipState | null',
      description: 'Get the current relationship state with an NPC',
      returns: 'NpcRelationshipState object with affinity, trust, romance, friendship',
      example: 'const rel = session.getNpcRelationship(42);'
    },
    {
      name: 'updateNpcRelationship',
      signature: '(npcId: number, patch: Partial<NpcRelationshipState>) => Promise<GameSessionDTO>',
      description: 'Update NPC relationship values',
      returns: 'Updated game session',
      example: 'await session.updateNpcRelationship(42, { affinity: 50, trust: 30 });'
    },
    {
      name: 'getInventory',
      signature: '() => InventoryItem[]',
      description: 'Get current player inventory',
      returns: 'Array of inventory items',
      example: 'const items = session.getInventory();'
    },
    {
      name: 'addInventoryItem',
      signature: '(itemId: string, quantity?: number) => Promise<GameSessionDTO>',
      description: 'Add item to player inventory',
      returns: 'Updated game session',
      example: 'await session.addInventoryItem("flower", 1);'
    },
    {
      name: 'removeInventoryItem',
      signature: '(itemId: string, quantity?: number) => Promise<GameSessionDTO>',
      description: 'Remove item from player inventory',
      returns: 'Updated game session',
      example: 'await session.removeInventoryItem("flower", 1);'
    },
    {
      name: 'updateArcStage',
      signature: '(arcId: string, stage: number) => Promise<GameSessionDTO>',
      description: 'Progress story arc to a new stage',
      returns: 'Updated game session',
      example: 'await session.updateArcStage("main_quest", 3);'
    },
    {
      name: 'markSceneSeen',
      signature: '(arcId: string, sceneId: number) => Promise<GameSessionDTO>',
      description: 'Mark a scene as seen in story tracking',
      returns: 'Updated game session',
      example: 'await session.markSceneSeen("main_quest", 42);'
    },
    {
      name: 'updateQuestStatus',
      signature: '(questId: string, status: QuestStatus) => Promise<GameSessionDTO>',
      description: 'Update quest status (pending/active/completed/failed)',
      returns: 'Updated game session',
      example: 'await session.updateQuestStatus("find_flower", "completed");'
    },
    {
      name: 'incrementQuestSteps',
      signature: '(questId: string, increment?: number) => Promise<GameSessionDTO>',
      description: 'Increment quest progress steps',
      returns: 'Updated game session',
      example: 'await session.incrementQuestSteps("collect_items", 1);'
    },
    {
      name: 'triggerEvent',
      signature: '(eventId: string) => Promise<GameSessionDTO>',
      description: 'Trigger a world event',
      returns: 'Updated game session',
      example: 'await session.triggerEvent("festival_started");'
    },
    {
      name: 'endEvent',
      signature: '(eventId: string) => Promise<GameSessionDTO>',
      description: 'End an active world event',
      returns: 'Updated game session',
      example: 'await session.endEvent("festival_started");'
    },
    {
      name: 'isEventActive',
      signature: '(eventId: string) => boolean',
      description: 'Check if a world event is currently active',
      returns: 'Boolean indicating event status',
      example: 'if (session.isEventActive("festival")) { ... }'
    }
  ];

  lines.push('| Function | Signature | Description |');
  lines.push('|----------|-----------|-------------|');
  helpers.forEach(helper => {
    lines.push(`| \`${helper.name}\` | \`${helper.signature}\` | ${helper.description} |`);
  });
  lines.push('');

  lines.push('### Detailed Documentation\n');

  helpers.forEach(helper => {
    lines.push(`#### \`${helper.name}\`\n`);
    lines.push(`${helper.description}\n`);

    lines.push('**Signature:**');
    lines.push('```typescript');
    lines.push(helper.signature);
    lines.push('```\n');

    lines.push('**Returns:** ' + helper.returns + '\n');

    lines.push('**Example:**');
    lines.push('```typescript');
    lines.push(helper.example);
    lines.push('```\n');

    lines.push('---\n');
  });

  lines.push('### Factory Function\n');
  lines.push('```typescript');
  lines.push('function createSessionHelpers(');
  lines.push('  gameSession: GameSessionDTO | null,');
  lines.push('  onUpdate?: (session: GameSessionDTO) => void,');
  lines.push('  api?: SessionAPI');
  lines.push('): SessionHelpers');
  lines.push('```\n');

  lines.push('**Usage in Interaction Context:**');
  lines.push('```typescript');
  lines.push('// Inside an interaction plugin execute method:');
  lines.push('async execute(config, context) {');
  lines.push('  // Access helpers via context.session');
  lines.push('  const rel = context.session.getNpcRelationship(npcId);');
  lines.push('  ');
  lines.push('  // Update with optimistic UI and server validation');
  lines.push('  await context.session.updateNpcRelationship(npcId, {');
  lines.push('    affinity: rel.affinity + 10');
  lines.push('  });');
  lines.push('  ');
  lines.push('  // Add items to inventory');
  lines.push('  await context.session.addInventoryItem("reward_token", 1);');
  lines.push('  ');
  lines.push('  return { success: true };');
  lines.push('}');
  lines.push('```\n');

  lines.push('### Optimistic Update Pattern\n');
  lines.push('Session helpers use optimistic updates for better UX:');
  lines.push('1. **Apply locally** - Change reflects in UI immediately');
  lines.push('2. **Validate server-side** - Send update to backend');
  lines.push('3. **Handle conflicts** - Resolve version mismatches automatically');
  lines.push('4. **Rollback on error** - Restore previous state if update fails\n');

  lines.push('```typescript');
  lines.push('// Behind the scenes:');
  lines.push('async updateNpcRelationship(npcId, patch) {');
  lines.push('  // 1. Optimistic update (instant UI)');
  lines.push('  const optimistic = applyLocalUpdate(session, patch);');
  lines.push('  onUpdate(optimistic);');
  lines.push('  ');
  lines.push('  // 2. Backend validation');
  lines.push('  try {');
  lines.push('    const response = await api.updateSession(session.id, {');
  lines.push('      relationships: patch,');
  lines.push('      expectedVersion: session.version');
  lines.push('    });');
  lines.push('    ');
  lines.push('    // 3. Handle conflicts');
  lines.push('    if (response.conflict) {');
  lines.push('      const resolved = resolveConflict(session, response.serverSession);');
  lines.push('      return api.updateSession(session.id, resolved);');
  lines.push('    }');
  lines.push('    ');
  lines.push('    onUpdate(response);');
  lines.push('    return response;');
  lines.push('  } catch (err) {');
  lines.push('    // 4. Rollback on error');
  lines.push('    onUpdate(session);');
  lines.push('    throw err;');
  lines.push('  }');
  lines.push('}');
  lines.push('```\n');

  return lines.join('\n');
}

/**
 * Main execution
 */
function main() {
  console.log('üîå Generating Plugin Documentation...\n');

  // Register all builtin node types
  registerBuiltinNodeTypes();

  const docs = generatePluginDocs();

  // Ensure docs directory exists
  const docsDir = path.join(process.cwd(), 'docs');
  if (!fs.existsSync(docsDir)) {
    fs.mkdirSync(docsDir, { recursive: true });
    console.log('üìÅ Created docs/ directory');
  }

  // Write documentation
  const outputPath = path.join(docsDir, 'PLUGIN_REFERENCE.md');
  fs.writeFileSync(outputPath, docs, 'utf-8');

  console.log(`‚úÖ Documentation generated successfully!`);
  console.log(`üìÑ Output: ${outputPath}`);
  console.log(`üìä Size: ${(docs.length / 1024).toFixed(2)} KB`);
  console.log(`üìù Lines: ${docs.split('\n').length}`);
  console.log('');
  console.log('üéâ Done! Check out the generated documentation.');
}

// Run if executed directly
if (require.main === module) {
  main();
}

export { generatePluginDocs, main };
