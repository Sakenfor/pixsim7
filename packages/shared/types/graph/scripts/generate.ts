#!/usr/bin/env tsx
/**
 * Generator for Zod validators and TypeScript types from graph.schema.json
 * Run: pnpm generate
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const schemaPath = path.join(__dirname, '../schema/graph.schema.json');
const outputPath = path.join(__dirname, '../src/generated.ts');

interface JsonSchema {
  $id?: string;
  $schema?: string;
  type: string;
  properties?: Record<string, any>;
  required?: string[];
  definitions?: Record<string, any>;
  enum?: string[];
  items?: any;
  additionalProperties?: any;
  minProperties?: number;
  pattern?: string;
  minLength?: number;
  minimum?: number;
  maxItems?: number;
  minItems?: number;
  description?: string;
  $ref?: string;
}

function parseRef(ref: string): string {
  return ref.replace('#/definitions/', '');
}

function generateZodForType(name: string, schema: JsonSchema, depth = 0): string {
  const indent = '  '.repeat(depth);

  if (schema.$ref) {
    return `${parseRef(schema.$ref)}Schema`;
  }

  if (schema.enum) {
    return `z.enum([${schema.enum.map(v => `"${v}"`).join(', ')}])`;
  }

  if (schema.type === 'string') {
    let zod = 'z.string()';
    if (schema.minLength !== undefined) zod += `.min(${schema.minLength})`;
    if (schema.pattern) zod += `.regex(/${schema.pattern.replace(/\\/g, '\\\\')}/)`;
    return zod;
  }

  if (schema.type === 'number' || schema.type === 'integer') {
    let zod = schema.type === 'integer' ? 'z.number().int()' : 'z.number()';
    if (schema.minimum !== undefined) zod += `.min(${schema.minimum})`;
    return zod;
  }

  if (schema.type === 'boolean') {
    return 'z.boolean()';
  }

  if (schema.type === 'array') {
    const itemSchema = schema.items ? generateZodForType(`${name}Item`, schema.items, depth) : 'z.unknown()';
    let zod = `z.array(${itemSchema})`;
    if (schema.minItems !== undefined) zod += `.min(${schema.minItems})`;
    if (schema.maxItems !== undefined) zod += `.max(${schema.maxItems})`;
    return zod;
  }

  if (schema.type === 'object') {
    if (schema.additionalProperties && !schema.properties) {
      // Record type
      if (typeof schema.additionalProperties === 'object') {
        const valueSchema = generateZodForType(`${name}Value`, schema.additionalProperties, depth);
        return `z.record(z.string(), ${valueSchema})`;
      }
      return 'z.record(z.string(), z.unknown())';
    }

    // Object with properties
    const props = schema.properties || {};
    const required = schema.required || [];
    const lines: string[] = [];

    for (const [key, propSchema] of Object.entries(props)) {
      const isRequired = required.includes(key);
      const propZod = generateZodForType(`${name}_${key}`, propSchema, depth + 1);
      const optional = isRequired ? '' : '.optional()';
      const desc = propSchema.description ? `.describe("${propSchema.description.replace(/"/g, '\\"')}")` : '';
      lines.push(`${indent}  ${key}: ${propZod}${optional}${desc},`);
    }

    return `z.object({\n${lines.join('\n')}\n${indent}})${schema.additionalProperties === false ? '.strict()' : ''}`;
  }

  // Fallback
  return 'z.unknown()';
}

function generateDefinition(name: string, schema: JsonSchema): string {
  const zodSchema = generateZodForType(name, schema, 0);
  return `export const ${name}Schema = ${zodSchema};\nexport type ${name} = z.infer<typeof ${name}Schema>;\n`;
}

function generate() {
  console.log('Reading schema from:', schemaPath);
  const schemaContent = fs.readFileSync(schemaPath, 'utf-8');
  const schema = JSON.parse(schemaContent);

  let output = `// AUTO-GENERATED by scripts/generate.ts - DO NOT EDIT MANUALLY
// Source: schema/graph.schema.json
// Generated: ${new Date().toISOString()}

import { z } from 'zod';

`;

  // Generate definitions first (order matters for dependencies)
  if (schema.definitions) {
    // Define in dependency order (manual ordering for now)
    const order = [
      'Condition',
      'EffectDescriptor',
      'VideoSegment',
      'VideoDescriptor',
      'SelectionStrategy',
      'EdgeDefinition',
      'GraphNode'
    ];

    for (const defName of order) {
      if (schema.definitions[defName]) {
        output += generateDefinition(defName, schema.definitions[defName]);
        output += '\n';
      }
    }

    // Add any remaining definitions not in order
    for (const [defName, defSchema] of Object.entries(schema.definitions)) {
      if (!order.includes(defName)) {
        output += generateDefinition(defName, defSchema as JsonSchema);
        output += '\n';
      }
    }
  }

  // Generate main Graph schema
  const mainSchema = {
    type: schema.type,
    properties: schema.properties,
    required: schema.required,
    additionalProperties: schema.additionalProperties
  };

  output += generateDefinition('Graph', mainSchema as JsonSchema);

  // Add helper types
  output += `
// Helper type exports
export type NodeType = GraphNode['type'];

// Node type discriminators
export type DecisionNode = Extract<GraphNode, { type: 'Decision' }>;
export type ConditionNode = Extract<GraphNode, { type: 'Condition' }>;
export type ActionNode = Extract<GraphNode, { type: 'Action' }>;
export type ChoiceNode = Extract<GraphNode, { type: 'Choice' }>;
export type VideoNode = Extract<GraphNode, { type: 'Video' }>;
export type RandomNode = Extract<GraphNode, { type: 'Random' }>;
export type TimerNode = Extract<GraphNode, { type: 'Timer' }>;
export type SceneCallNode = Extract<GraphNode, { type: 'SceneCall' }>;
export type SubgraphNode = Extract<GraphNode, { type: 'Subgraph' }>;

// Condition kind type
export type ConditionKind = Condition['kind'];
`;

  fs.writeFileSync(outputPath, output, 'utf-8');
  console.log('Generated:', outputPath);
}

generate();
