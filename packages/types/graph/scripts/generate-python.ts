#!/usr/bin/env tsx
/**
 * Generator for Python Pydantic models from graph.schema.json
 * Run: tsx scripts/generate-python.ts
 *
 * Outputs to: pixsim7_game_service/domain/graph/models.py
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const schemaPath = path.join(__dirname, '../schema/graph.schema.json');
const outputPath = path.join(__dirname, '../../../pixsim7_game_service/domain/graph/models.py');

interface JsonSchema {
  type: string;
  properties?: Record<string, any>;
  required?: string[];
  definitions?: Record<string, any>;
  enum?: string[];
  items?: any;
  additionalProperties?: any;
  description?: string;
  $ref?: string;
}

function parseRef(ref: string): string {
  return ref.replace('#/definitions/', '');
}

function jsonTypeToPython(schema: JsonSchema, optional = false): string {
  if (schema.$ref) {
    const refName = parseRef(schema.$ref);
    return optional ? `Optional[${refName}]` : refName;
  }

  if (schema.enum) {
    // Return Literal type for enums
    return `Literal[${schema.enum.map(v => `"${v}"`).join(', ')}]`;
  }

  if (schema.type === 'string') return optional ? 'Optional[str]' : 'str';
  if (schema.type === 'number') return optional ? 'Optional[float]' : 'float';
  if (schema.type === 'integer') return optional ? 'Optional[int]' : 'int';
  if (schema.type === 'boolean') return optional ? 'Optional[bool]' : 'bool';

  if (schema.type === 'array') {
    const itemType = schema.items ? jsonTypeToPython(schema.items, false) : 'Any';
    return optional ? `Optional[list[${itemType}]]` : `list[${itemType}]`;
  }

  if (schema.type === 'object') {
    if (schema.additionalProperties && !schema.properties) {
      const valueType = typeof schema.additionalProperties === 'object'
        ? jsonTypeToPython(schema.additionalProperties, false)
        : 'Any';
      return optional ? `Optional[dict[str, ${valueType}]]` : `dict[str, ${valueType}]`;
    }
    return optional ? 'Optional[dict[str, Any]]' : 'dict[str, Any]';
  }

  return optional ? 'Optional[Any]' : 'Any';
}

function generatePydanticModel(name: string, schema: JsonSchema, indent = 0): string {
  const ind = '    '.repeat(indent);
  const lines: string[] = [];

  // Class definition
  lines.push(`${ind}class ${name}(BaseModel):`);

  // Docstring
  if (schema.description) {
    lines.push(`${ind}    """${schema.description}"""`);
  }

  // Fields
  const props = schema.properties || {};
  const required = schema.required || [];

  if (Object.keys(props).length === 0) {
    lines.push(`${ind}    pass`);
  } else {
    for (const [fieldName, fieldSchema] of Object.entries(props)) {
      const isRequired = required.includes(fieldName);
      const pythonType = jsonTypeToPython(fieldSchema, !isRequired);
      const defaultValue = isRequired ? '' : ' = None';
      const description = fieldSchema.description ? `  # ${fieldSchema.description}` : '';

      // Handle special field attributes
      let fieldDef = `${ind}    ${fieldName}: ${pythonType}${defaultValue}${description}`;

      // Add Field() for constrained types
      if (fieldSchema.minLength !== undefined || fieldSchema.pattern !== undefined || fieldSchema.minimum !== undefined) {
        const constraints: string[] = [];
        if (fieldSchema.minLength !== undefined) constraints.push(`min_length=${fieldSchema.minLength}`);
        if (fieldSchema.minimum !== undefined) constraints.push(`ge=${fieldSchema.minimum}`);
        if (fieldSchema.pattern) constraints.push(`pattern=r"${fieldSchema.pattern}"`);

        if (constraints.length > 0) {
          fieldDef = `${ind}    ${fieldName}: ${pythonType} = Field(${defaultValue ? 'None, ' : ''}${constraints.join(', ')})${description}`;
        }
      }

      lines.push(fieldDef);
    }
  }

  // Config
  lines.push(`${ind}    model_config = ConfigDict(extra='forbid')`);

  return lines.join('\n');
}

function generate() {
  console.log('Reading schema from:', schemaPath);
  const schemaContent = fs.readFileSync(schemaPath, 'utf-8');
  const schema = JSON.parse(schemaContent);

  let output = `# AUTO-GENERATED by packages/types/graph/scripts/generate-python.ts
# DO NOT EDIT MANUALLY
# Source: packages/types/graph/schema/graph.schema.json
# Generated: ${new Date().toISOString()}

from __future__ import annotations
from typing import Any, Optional, Literal
from pydantic import BaseModel, Field, ConfigDict

`;

  // Generate definitions in dependency order
  const order = [
    'Condition',
    'EffectDescriptor',
    'VideoSegment',
    'VideoDescriptor',
    'SelectionStrategy',
    'EdgeDefinition',
    'GraphNode'
  ];

  for (const defName of order) {
    if (schema.definitions[defName]) {
      output += generatePydanticModel(defName, schema.definitions[defName], 0);
      output += '\n\n';
    }
  }

  // Generate main Graph model
  const mainSchema = {
    type: schema.type,
    properties: schema.properties,
    required: schema.required,
    description: schema.description,
  };

  output += generatePydanticModel('Graph', mainSchema as JsonSchema, 0);
  output += '\n\n';

  // Add helper types
  output += `# Type aliases for convenience
NodeType = Literal[
    "Decision", "Condition", "Action", "Choice", "Video",
    "Random", "Timer", "SceneCall", "Subgraph"
]

ConditionKind = Literal[
    "weekday", "weekend", "timeBetween", "timeAfter", "timeBefore",
    "needLt", "needGt", "needBetween",
    "hasFlag", "notFlag", "anyFlag", "allFlags",
    "locationIs", "locationNot",
    "moneyGt", "moneyLt",
    "relationshipGt", "relationshipLt",
    "randomChance", "tickMod",
    "activityIs", "activityNot",
    "and", "or", "not"
]
`;

  // Ensure output directory exists
  const outputDir = path.dirname(outputPath);
  fs.mkdirSync(outputDir, { recursive: true });

  fs.writeFileSync(outputPath, output, 'utf-8');
  console.log('Generated:', outputPath);
}

generate();
