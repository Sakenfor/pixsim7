#!/usr/bin/env python3
"""
Generate API endpoint documentation from OpenAPI spec.

Reads the OpenAPI JSON from the backend (default: http://localhost:8000/openapi.json)
or from a local file, and generates a markdown reference document.

Usage:
    python scripts/gen_openapi_docs.py                    # Fetch from running backend
    python scripts/gen_openapi_docs.py --input spec.json # Use local file

Output: docs/api/ENDPOINTS.md

Exit codes:
    0 - Success
    1 - Error (missing input, parse error, etc.)
"""

import argparse
import json
import sys
import urllib.request
import urllib.error
from pathlib import Path
from typing import Any


DEFAULT_URL = "http://localhost:8000/openapi.json"
DEFAULT_OUTPUT = "docs/api/ENDPOINTS.md"


def fetch_openapi_from_url(url: str) -> dict:
    """Fetch OpenAPI spec from a URL."""
    try:
        with urllib.request.urlopen(url, timeout=10) as response:
            return json.loads(response.read().decode("utf-8"))
    except urllib.error.URLError as e:
        print(f"Error: Could not fetch OpenAPI spec from {url}")
        print(f"  {e}")
        print()
        print("Make sure the backend is running:")
        print("  PYTHONPATH=. uvicorn pixsim7.backend.main.main:app --port 8000")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON from {url}: {e}")
        sys.exit(1)


def load_openapi_from_file(path: Path) -> dict:
    """Load OpenAPI spec from a local file."""
    if not path.exists():
        print(f"Error: OpenAPI file not found: {path}")
        sys.exit(1)

    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in {path}: {e}")
        sys.exit(1)


def get_auth_requirement(operation: dict) -> str:
    """Determine if endpoint requires authentication."""
    security = operation.get("security", [])
    if security:
        # Has security requirements
        return "Yes"
    return "No"


def generate_endpoint_docs(spec: dict) -> str:
    """Generate markdown documentation from OpenAPI spec."""
    lines = []

    # Header
    lines.append("# API Endpoints Reference")
    lines.append("")
    lines.append("<!-- AUTO-GENERATED FILE - DO NOT EDIT MANUALLY -->")
    lines.append("<!-- Generated by: python scripts/gen_openapi_docs.py -->")
    lines.append("")

    # Info section
    info = spec.get("info", {})
    title = info.get("title", "API")
    version = info.get("version", "")
    if version:
        lines.append(f"**API Version:** {version}")
        lines.append("")

    # Collect endpoints by tag
    endpoints_by_tag: dict[str, list[dict]] = {}
    paths = spec.get("paths", {})

    for path, path_item in paths.items():
        for method in ["get", "post", "put", "patch", "delete", "head", "options"]:
            if method not in path_item:
                continue

            operation = path_item[method]
            tags = operation.get("tags", ["untagged"])

            endpoint_info = {
                "method": method.upper(),
                "path": path,
                "summary": operation.get("summary", ""),
                "operation_id": operation.get("operationId", ""),
                "description": operation.get("description", ""),
                "auth": get_auth_requirement(operation),
                "deprecated": operation.get("deprecated", False),
            }

            for tag in tags:
                if tag not in endpoints_by_tag:
                    endpoints_by_tag[tag] = []
                endpoints_by_tag[tag].append(endpoint_info)

    # Sort tags alphabetically
    sorted_tags = sorted(endpoints_by_tag.keys())

    # Table of contents
    lines.append("## Table of Contents")
    lines.append("")
    for tag in sorted_tags:
        anchor = tag.lower().replace(" ", "-").replace("_", "-")
        lines.append(f"- [{tag}](#{anchor})")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Generate sections by tag
    for tag in sorted_tags:
        endpoints = endpoints_by_tag[tag]

        # Sort endpoints by path, then method
        endpoints.sort(key=lambda e: (e["path"], e["method"]))

        lines.append(f"## {tag}")
        lines.append("")
        lines.append("| Method | Path | Summary | Auth |")
        lines.append("|--------|------|---------|------|")

        for ep in endpoints:
            method = ep["method"]
            path = ep["path"]
            summary = ep["summary"] or ep["operation_id"] or "-"
            auth = ep["auth"]

            # Mark deprecated endpoints
            if ep["deprecated"]:
                summary = f"~~{summary}~~ (deprecated)"

            # Escape pipe characters in summary
            summary = summary.replace("|", "\\|")

            lines.append(f"| `{method}` | `{path}` | {summary} | {auth} |")

        lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*This file is auto-generated. Do not edit manually.*")
    lines.append("")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Generate API endpoint documentation from OpenAPI spec"
    )
    parser.add_argument(
        "--input",
        type=str,
        help=f"Path to OpenAPI JSON file (default: fetch from {DEFAULT_URL})",
    )
    parser.add_argument(
        "--output",
        type=str,
        default=DEFAULT_OUTPUT,
        help=f"Output markdown file (default: {DEFAULT_OUTPUT})",
    )
    args = parser.parse_args()

    # Get project root
    project_root = Path(__file__).parent.parent

    # Load OpenAPI spec
    if args.input:
        input_path = Path(args.input)
        if not input_path.is_absolute():
            input_path = project_root / input_path
        print(f"Loading OpenAPI spec from: {input_path}")
        spec = load_openapi_from_file(input_path)
    else:
        print(f"Fetching OpenAPI spec from: {DEFAULT_URL}")
        spec = fetch_openapi_from_url(DEFAULT_URL)

    # Generate documentation
    print("Generating endpoint documentation...")
    content = generate_endpoint_docs(spec)

    # Write output
    output_path = project_root / args.output
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(content)

    # Count endpoints
    paths = spec.get("paths", {})
    endpoint_count = sum(
        1
        for path_item in paths.values()
        for method in ["get", "post", "put", "patch", "delete", "head", "options"]
        if method in path_item
    )

    print(f"Generated: {args.output}")
    print(f"  {endpoint_count} endpoints documented")


if __name__ == "__main__":
    main()
