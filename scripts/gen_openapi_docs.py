#!/usr/bin/env python3
"""
Generate API endpoint documentation from OpenAPI spec.

Reads the OpenAPI JSON from a local file (default: pixsim7/backend/main/openapi.json),
from a file provided via --input, or from a URL via --url, and generates a markdown
reference document.

Usage:
    python scripts/gen_openapi_docs.py                     # Use default local OpenAPI JSON
    python scripts/gen_openapi_docs.py --input spec.json  # Use local file
    python scripts/gen_openapi_docs.py --url http://localhost:8000/openapi.json
    python scripts/gen_openapi_docs.py --service main-api

Output: docs/api/ENDPOINTS.md

Exit codes:
    0 - Success
    1 - Error (missing input, parse error, etc.)
"""

import argparse
import json
import os
import sys
import urllib.error
import urllib.request
from pathlib import Path


DEFAULT_INPUT = "pixsim7/backend/main/openapi.json"
DEFAULT_URL = "http://localhost:8000/openapi.json"
DEFAULT_OUTPUT = "docs/api/ENDPOINTS.md"
DEFAULT_SERVICES_CONFIG = "launcher/services.json"


def load_openapi_from_file(path: Path) -> dict:
    """Load OpenAPI spec from a local file."""
    if not path.exists():
        print(f"Error: OpenAPI file not found: {path}")
        sys.exit(1)

    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in {path}: {e}")
        sys.exit(1)


def fetch_openapi_from_url(url: str) -> dict:
    """Fetch OpenAPI spec from a URL."""
    try:
        with urllib.request.urlopen(url, timeout=10) as response:
            return json.loads(response.read().decode("utf-8"))
    except urllib.error.URLError as e:
        print(f"Error: Could not fetch OpenAPI spec from {url}")
        print(f"  {e}")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON from {url}: {e}")
        sys.exit(1)


def load_services_config(path: Path) -> dict | None:
    """Load services.json config if present."""
    if not path.exists():
        return None
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in {path}: {e}")
        sys.exit(1)


def resolve_service_config(config: dict, service_id: str) -> dict | None:
    """Find a backend service definition by id."""
    for service in config.get("backend_services", []):
        if service.get("id") == service_id:
            return service
    return None


def resolve_service_openapi_url(service: dict) -> str | None:
    """Resolve OpenAPI URL from a backend service config."""
    base_url = None
    base_url_env = service.get("base_url_env")
    if base_url_env:
        base_url = os.getenv(base_url_env)

    if not base_url:
        port_env = service.get("port_env")
        port = os.getenv(port_env) if port_env else None
        if not port:
            port = service.get("default_port")
        if port:
            base_url = f"http://localhost:{port}"

    if not base_url:
        return None

    endpoint = service.get("openapi_endpoint") or "/openapi.json"
    if not endpoint.startswith("/"):
        endpoint = f"/{endpoint}"

    return f"{base_url.rstrip('/')}{endpoint}"


def get_auth_requirement(spec: dict, operation: dict) -> str:
    """Determine if endpoint requires authentication."""
    if "security" in operation:
        security = operation.get("security", [])
    else:
        security = spec.get("security", [])
    return "Yes" if security else "No"


def generate_endpoint_docs(spec: dict) -> str:
    """Generate markdown documentation from OpenAPI spec."""
    lines = []

    # Header
    lines.append("# API Endpoints Reference")
    lines.append("")
    lines.append("<!-- AUTO-GENERATED FILE - DO NOT EDIT MANUALLY -->")
    lines.append("<!-- Generated by: python scripts/gen_openapi_docs.py -->")
    lines.append("")

    # Info section
    info = spec.get("info", {})
    version = info.get("version", "")
    if version:
        lines.append(f"**API Version:** {version}")
        lines.append("")

    # Collect endpoints by tag
    endpoints_by_tag: dict[str, list[dict]] = {}
    paths = spec.get("paths", {})

    for path, path_item in paths.items():
        for method in ["get", "post", "put", "patch", "delete", "head", "options"]:
            if method not in path_item:
                continue

            operation = path_item[method]
            tags = operation.get("tags", ["untagged"])

            endpoint_info = {
                "method": method.upper(),
                "path": path,
                "summary": operation.get("summary", ""),
                "operation_id": operation.get("operationId", ""),
                "description": operation.get("description", ""),
                "auth": get_auth_requirement(spec, operation),
                "deprecated": operation.get("deprecated", False),
            }

            for tag in tags:
                if tag not in endpoints_by_tag:
                    endpoints_by_tag[tag] = []
                endpoints_by_tag[tag].append(endpoint_info)

    # Sort tags alphabetically
    sorted_tags = sorted(endpoints_by_tag.keys())

    # Table of contents
    lines.append("## Table of Contents")
    lines.append("")
    for tag in sorted_tags:
        anchor = tag.lower().replace(" ", "-").replace("_", "-")
        lines.append(f"- [{tag}](#{anchor})")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Generate sections by tag
    for tag in sorted_tags:
        endpoints = endpoints_by_tag[tag]

        # Sort endpoints by path, then method
        endpoints.sort(key=lambda e: (e["path"], e["method"]))

        lines.append(f"## {tag}")
        lines.append("")
        lines.append("| Method | Path | Summary | Auth |")
        lines.append("|--------|------|---------|------|")

        for ep in endpoints:
            method = ep["method"]
            path = ep["path"]
            summary = ep["summary"] or ep["operation_id"] or "-"
            auth = ep["auth"]

            # Mark deprecated endpoints
            if ep["deprecated"]:
                summary = f"~~{summary}~~ (deprecated)"

            # Escape pipe characters in summary
            summary = summary.replace("|", "\\|")

            lines.append(f"| `{method}` | `{path}` | {summary} | {auth} |")

        lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*This file is auto-generated. Do not edit manually.*")
    lines.append("")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Generate API endpoint documentation from OpenAPI spec"
    )
    parser.add_argument(
        "--input",
        type=str,
        help=f"Path to OpenAPI JSON file (default: {DEFAULT_INPUT})",
    )
    parser.add_argument(
        "--url",
        type=str,
        help=f"OpenAPI URL to fetch (default: {DEFAULT_URL})",
    )
    parser.add_argument(
        "--output",
        type=str,
        help=f"Output markdown file (default: {DEFAULT_OUTPUT})",
    )
    parser.add_argument(
        "--service",
        type=str,
        help="Backend service id from launcher/services.json",
    )
    parser.add_argument(
        "--services-config",
        type=str,
        help=f"Path to services.json (default: {DEFAULT_SERVICES_CONFIG})",
    )
    args = parser.parse_args()

    # Get project root
    project_root = Path(__file__).parent.parent
    output_was_set = "--output" in sys.argv

    service_id = args.service or os.getenv("OPENAPI_SERVICE")
    if service_id:
        services_config_path = Path(
            args.services_config
            if args.services_config
            else os.getenv("OPENAPI_SERVICES_CONFIG", DEFAULT_SERVICES_CONFIG)
        )
        if not services_config_path.is_absolute():
            services_config_path = project_root / services_config_path

        config = load_services_config(services_config_path)
        if not config:
            print(f"Error: services config not found: {services_config_path}")
            sys.exit(1)

        service_config = resolve_service_config(config, service_id)
        if not service_config:
            print(f"Error: OpenAPI service not found: {service_id}")
            sys.exit(1)

        service_url = resolve_service_openapi_url(service_config)
        if not service_url:
            print(f"Error: Could not resolve OpenAPI URL for {service_id}")
            sys.exit(1)
    else:
        service_url = None

    # Resolve input path
    if args.input:
        input_path = Path(args.input)
        if not input_path.is_absolute():
            input_path = project_root / input_path
        if not input_path.exists():
            print(f"Error: OpenAPI file not found: {input_path}")
            sys.exit(1)
        print(f"Loading OpenAPI spec from: {input_path}")
        spec = load_openapi_from_file(input_path)
    elif args.url:
        print(f"Fetching OpenAPI spec from: {args.url}")
        spec = fetch_openapi_from_url(args.url)
    elif service_url:
        print(f"Fetching OpenAPI spec from: {service_url}")
        spec = fetch_openapi_from_url(service_url)
    else:
        input_path = project_root / DEFAULT_INPUT
        if not input_path.exists():
            print(f"Error: Default OpenAPI file not found: {input_path}")
            print("Provide --input or --url to generate docs.")
            sys.exit(1)
        print(f"Loading OpenAPI spec from: {input_path}")
        spec = load_openapi_from_file(input_path)

    # Generate documentation
    print("Generating endpoint documentation...")
    content = generate_endpoint_docs(spec)

    # Write output
    output = args.output
    if not output:
        if service_id and service_id != "main-api" and not output_was_set:
            output = f"docs/api/ENDPOINTS.{service_id}.md"
        else:
            output = DEFAULT_OUTPUT

    output_path = project_root / output
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(content)

    # Count endpoints
    paths = spec.get("paths", {})
    endpoint_count = sum(
        1
        for path_item in paths.values()
        for method in ["get", "post", "put", "patch", "delete", "head", "options"]
        if method in path_item
    )

    print(f"Generated: {output}")
    print(f"  {endpoint_count} endpoints documented")


if __name__ == "__main__":
    main()
