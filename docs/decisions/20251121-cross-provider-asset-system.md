# ADR: Cross-Provider Asset System

- **Date:** 2025-11-21
- **Status:** Accepted
- **Authors:** PixSim7 Team

---

## Context

PixSim7 integrates multiple video generation providers (Pixverse, Sora, etc.). Each provider has its own asset storage and requirements:

- **Pixverse** stores assets in its own cloud, requires upload via API
- **Sora** (planned) has different storage and upload mechanisms
- **Future providers** will have their own asset management

Users want to:
1. Use an asset generated by Provider A as input for Provider B
2. Branch narratives where one video leads to multiple variations via different providers
3. Track asset lineage (which assets were derived from which)
4. Cache downloaded assets locally to avoid re-downloading

### Problem

Without a cross-provider asset system:
- ❌ Users must manually download from Provider A and upload to Provider B
- ❌ No lineage tracking between assets across providers
- ❌ Redundant downloads waste bandwidth and time
- ❌ No caching strategy for frequently used assets

### Constraints

- Provider APIs have different upload mechanisms
- Download/upload takes time - must be efficient
- Local storage is limited - need eviction strategy
- Must work with existing Asset model and database
- Must support future providers without major refactoring

### Alternatives Considered

1. **Manual Cross-Provider Workflow**
   - Users download and re-upload manually
   - ❌ Rejected: Poor UX, error-prone, no automation

2. **Centralized Asset Storage**
   - Store all assets in our own cloud storage
   - ❌ Rejected: High storage costs, bandwidth costs, operational overhead

3. **Universal Asset Format**
   - Convert all assets to standard format
   - ❌ Rejected: Quality loss, processing time, complexity

4. **Automatic Upload/Download with Local Cache (chosen)**
   - Download assets as needed, cache locally, upload to target provider
   - Track lineage and relationships in database
   - ✅ Accepted: Best balance of UX, cost, and complexity

---

## Decision

PixSim7 implements an **automatic cross-provider asset system** with the following components:

### Core Mechanism: `get_asset_for_provider()`

```python
# In AssetService
async def get_asset_for_provider(
    self,
    asset_id: int,
    target_provider_id: str
) -> str:
    """
    Get asset ready for use with target provider.
    Returns provider-specific asset URL/ID.

    Automatically:
    1. Downloads asset if not cached locally
    2. Uploads to target provider if needed
    3. Caches the provider-specific URL
    4. Updates last_accessed_at for LRU eviction
    """
```

### Architecture Components

1. **Asset Model Extensions**
   - `provider_urls: Dict[str, str]` - Cache of provider-specific URLs
   - `local_path: str | None` - Path to locally cached file
   - `last_accessed_at: datetime` - For LRU eviction
   - `lineage` relationship - Track parent/child assets

2. **AssetLineage Model**
   - Links parent asset to child assets
   - Tracks transformation type (e.g., "img2vid", "style_transfer")
   - Supports branching narratives

3. **Provider Adapter Interface**
   ```python
   class BaseProvider:
       async def upload_asset(self, account, file_path: str) -> str:
           """Upload asset, return provider-specific URL/ID"""

       async def download_asset(self, account, asset_url: str, dest_path: str):
           """Download asset from provider"""
   ```

4. **Local Cache Strategy**
   - Assets stored in `data/cache/assets/{asset_id}/{filename}`
   - LRU eviction based on `last_accessed_at` (future work)
   - Configurable cache size limit

### Workflow

**User creates job with cross-provider asset:**
1. User selects Asset A (from Pixverse) as input for Sora job
2. System calls `get_asset_for_provider(asset_a.id, "sora")`
3. System checks `asset_a.provider_urls["sora"]` - not found
4. System checks `asset_a.local_path` - not found
5. System downloads from Pixverse to local cache
6. System uploads to Sora, gets Sora-specific URL
7. System stores Sora URL in `asset_a.provider_urls["sora"]`
8. Job proceeds with Sora-specific URL
9. Resulting asset gets lineage link: parent = Asset A

**User reuses same asset with Sora later:**
1. System calls `get_asset_for_provider(asset_a.id, "sora")`
2. System finds `asset_a.provider_urls["sora"]` - returns cached URL
3. No download or upload needed!

### Key Principles

**We ARE:**
- Automatically handling cross-provider asset transfers
- Caching provider-specific URLs in database
- Caching files locally with LRU eviction (future)
- Tracking lineage between assets
- Supporting branching (one asset → many children)

**We are NOT:**
- Storing assets permanently in our own cloud
- Converting or transcoding assets
- Guaranteeing indefinite availability (providers may expire URLs)
- Supporting every possible asset format

---

## Consequences

### Positive

1. **Seamless UX**
   - Users don't need to manually download/upload
   - Cross-provider workflows "just work"
   - Fast when URLs are cached

2. **Lineage Tracking**
   - Can trace asset relationships
   - Supports narrative branching
   - Enables "where was this used?" queries

3. **Efficiency**
   - Cached provider URLs avoid re-uploads
   - Local cache avoids re-downloads
   - Only transfer data when needed

4. **Extensibility**
   - New providers just implement upload/download interface
   - No changes to core asset service
   - Provider-specific logic isolated in adapters

### Trade-offs

1. **Local Storage**
   - Cached assets consume disk space
   - Need eviction strategy (LRU planned)
   - Need monitoring and limits

2. **Complexity**
   - More moving parts (download, cache, upload)
   - Must handle failures at each step
   - Race conditions if same asset requested concurrently

3. **Eventual Consistency**
   - Provider URLs may expire
   - Cached data may become stale
   - Need re-validation logic (future)

4. **Provider Coupling**
   - Each provider needs upload/download implementation
   - Provider API changes affect this system
   - Testing requires provider credentials

### Risks & Mitigation

**Risk:** Disk space exhaustion
- **Mitigation:** LRU eviction, configurable cache size, monitoring

**Risk:** Provider URL expiration
- **Mitigation:** Re-validate on failure, re-upload if needed, TTL tracking (future)

**Risk:** Download/upload failures
- **Mitigation:** Retry logic, exponential backoff, error logging

**Risk:** Race conditions (concurrent requests for same asset)
- **Mitigation:** File locking, request deduplication (future)

### Migration Strategy

This system was built from the start, so no migration needed. Future enhancements:
1. Implement LRU eviction worker
2. Add TTL validation for provider URLs
3. Add request deduplication for concurrent transfers
4. Add cache warming for frequently used assets

---

## Related Code / Docs

### Code
- **`pixsim7/backend/main/services/asset/asset_service.py`** (lines 338-503)
  - `get_asset_for_provider()` implementation
- **`pixsim7/backend/main/domain/asset.py`**
  - Asset model with `provider_urls`, `local_path`, `last_accessed_at`
- **`pixsim7/backend/main/domain/asset_lineage.py`**
  - AssetLineage, AssetBranch models
- **`pixsim7/backend/main/services/provider/base.py`**
  - BaseProvider interface with `upload_asset()`, `download_asset()`
- **`pixsim7/backend/main/services/provider/adapters/pixverse.py`** (lines 600-700)
  - Pixverse upload/download implementation

### Docs
- **`ARCHITECTURE.md`** - Asset system overview
- **`AI_README.md`** - Asset service reference (lines 83-86)
- **`docs/backend/SERVICES.md`** - AssetService documentation

### Related ADRs
- **`20251121-extension-architecture.md`** - Provider adapters as extensions
